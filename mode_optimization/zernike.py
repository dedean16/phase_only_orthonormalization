import torch
from helper_functions import n_choose_k, factorial


def zernike_cart(x, y, n, m, circle=False, dtype=torch.float32):
    """
    Zernike Cartesian
    
    Original author of Matlab version: Giulia Sereni
    Translated to Python by: Daniël Cox
    Purpose: calculate the zernike functions described 
    in "Efficient cartesian representation of zernike polynomials in 
    computer memory. Hedser H. van Brug. Proc. SPIE 3190, (1997). 
    doi: 10.1117/12.294412"

    Args:
        x: x coordinates, typically from -1 to +1. Shape: 1xNx... tensor.
        y: y coordinates, typically from -1 to +1. Shape: Nx1x... tensor.
        n: The radial order of the zernike function. This can be generated by the 'zernike_order' function.
        m: The azimuthal order generated by the 'zernike_order' function.
        circle: If true, values outside the unit circle will be set to 0.
        dtype: Datatype to use.

    Returns:
        U = zernike function for a given n and m whose size is given by the
        coord_x and coord_y. it is a square matrix.
    """

    # if n and m are arrays, construct zernike modes for each entry in n
    # and store them in a multi-dimensional array

    if m > n:
        raise 'Each m must be less than or equal to its corresponding n.'

    l = n - 2*m

    if l > 0:
        p = 1
    else:
        p = 0

    if (l > 0) and (n % 2 == 0):
        q = abs(l) / 2 - 1
    elif l <= 0 and (n % 2 == 0):
        q = abs(l) / 2
    elif n % 2 != 0:
        q = (abs(l) - 1) / 2
    else:
        raise 'Something went wrong!'

    M = (n - abs(l)) / 2
    U = 0

    for r in range(int(q+1)):
        for j in range(int(M+1)):
            sign = ((-1)**(r+j))
            for k in range(int(M-j+1)):
                U = U + sign * (n_choose_k(abs(l), 2*r+p) * n_choose_k(M-j, k)) * \
                    ((factorial(n-j)) / (factorial(j) * factorial(M-j) * factorial(n-M-j))) \
                    * (x**(n-2*(r+j+k)-p) * y**(2*(r+k)+p))

    if circle:
        U[(x**2 + y**2) > 1] = 0

    return U


def zernike_order(j):
    """
    Zernike order

    Original author of Matlab version: Giulia Sereni
    Translated to Python by: Daniël Cox

    Compute zernike mode radial and azimuthal order n, m, from index j, as defined in DOI:10.1117/12.294412.

    Args:
        j: Zernike mode index.

    Returns:
        n: is the radial order of the zernike function.
        m: is the azimuthal order.
    """
    if j is not torch.Tensor:
        j = torch.tensor(j)

    n = torch.ceil(-1.5 + 0.5 * torch.sqrt(1+j*8))          # Radial order
    m = n-j + 1 + (n+1)*n/2                                 # Azimuthal order
    return n, m
